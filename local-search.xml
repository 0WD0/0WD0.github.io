<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>P5121</title>
    <link href="/2022/05/30/P5121/"/>
    <url>/2022/05/30/P5121/</url>
    
    <content type="html"><![CDATA[<p>[[implementation]] <a href="https://www.luogu.com.cn/problem/P5121">link</a></p><pre><code class="hljs">while(还有可以删的连通块)&#123;    找连通块，判断连通块大小，删除或不删；    掉落；&#125;</code></pre><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,cnt,vis[<span class="hljs-number">111</span>][<span class="hljs-number">11</span>],li[<span class="hljs-number">1110</span>],dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,c,cn,la,ga;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">111</span>][<span class="hljs-number">11</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>vis[x][y]=cn;c++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-keyword">if</span>(!vis[x+dx[i]][y+dy[i]]&amp;&amp;ch[x+dx[i]][y+dy[i]]==ch[x][y])<span class="hljs-built_in">dfs</span>(x+dx[i],y+dy[i]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)cin&gt;&gt;ch[i][j];<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>cnt=cn=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(li,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> li);<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)<span class="hljs-keyword">if</span>(!vis[i][j]&amp;&amp;ch[i][j]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>cn++,c=<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(i,j);<br><span class="hljs-keyword">if</span>(c&gt;=k)li[cn]=<span class="hljs-number">1</span>,cnt++;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)<span class="hljs-keyword">if</span>(li[vis[i][j]])ch[i][j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)&#123;<br><span class="hljs-keyword">for</span>(la=i=n;i&amp;&amp;ch[i][j]!=<span class="hljs-string">&#x27;0&#x27;</span>;i--,la--);<br><span class="hljs-keyword">for</span>(;i;)&#123;<br><span class="hljs-keyword">if</span>(ch[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br><span class="hljs-keyword">for</span>(;i&amp;&amp;ch[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>;i--);<br>ga=la-i;<br><span class="hljs-keyword">for</span>(;i&amp;&amp;ch[i][j]!=<span class="hljs-string">&#x27;0&#x27;</span>;i--)ch[i+ga][j]=ch[i][j],ch[i][j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>la=i+ga;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!cnt)<span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;cout&lt;&lt;endl,i++)<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)cout&lt;&lt;ch[i][j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1662N</title>
    <link href="/2022/05/30/CF1662N/"/>
    <url>/2022/05/30/CF1662N/</url>
    
    <content type="html"><![CDATA[<p>[[math]] <a href="https://codeforces.com/problemset/problem/1662/N">link</a></p><p>Let <span class="math inline">\(a&lt;b&lt;c&lt;d\)</span>, ignoring the direction. There are two passible situations: <span class="math inline">\(a\)</span> <span class="math inline">\(b\)</span> | <span class="math inline">\(a\)</span> <span class="math inline">\(b\)</span> <span class="math inline">\(c\)</span> <span class="math inline">\(d\)</span> | <span class="math inline">\(d\)</span> <span class="math inline">\(c\)</span></p><p>That's all.</p><p><em>Discovered what?</em></p><p><span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> must in the middle of the vertices near it.</p><p>And rectangles which aren't eligible must don't satisfy the description above.</p><p>And it's doesn't matter that whether "<span class="math inline">\(b\)</span>" and "<span class="math inline">\(c\)</span>" is in the same column or row or neither.</p><p>Therefore, the answer is the number of "<span class="math inline">\(b\)</span>" ("<span class="math inline">\(c\)</span>" and "<span class="math inline">\(b\)</span>" have same features, so the answer should divided by 2).</p><p>We can use <code>sort()</code> and <code>lower_bound()</code> to compute the rank of <span class="math inline">\(x_{i,j}\)</span> in the column and row.</p><p>Complexity: <span class="math inline">\(O(n^2\log n)\)</span></p><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1502</span>;<br><span class="hljs-type">int</span> n,m,x[N][N],b[N],prel[N][N],sufl[N][N],prec[N][N],sufc[N][N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>cin&gt;&gt;x[i][j];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)b[j]=x[i][j];<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)prel[i][j]=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n,x[i][j])-b<span class="hljs-number">-1</span>,sufl[i][j]=n-prel[i][j]<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)b[j]=x[j][i];<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)prec[j][i]=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n,x[j][i])-b<span class="hljs-number">-1</span>,sufc[j][i]=n-prec[j][i]<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>ans+=prel[i][j]*sufc[i][j]+prec[i][j]*sufl[i][j];<br>fout&lt;&lt;ans/<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="im-the-first-solver-of-this-problem-in-cf">I'm the first solver of this problem in CF!</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1662L</title>
    <link href="/2022/05/30/CF1662L/"/>
    <url>/2022/05/30/CF1662L/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] [[conversion]] <a href="https://codeforces.com/problemset/problem/1662/L">link</a></p><h2 id="tutorial-on-cf">Tutorial on CF</h2><p>Let <span class="math inline">\(x_i:=vt_i−a_i\)</span> and <span class="math inline">\(y_i:=vt_i+a_i\)</span> for <span class="math inline">\(i=1,…,n\)</span>. The main observation to solve this problem is that a sequence of kicks with indices <span class="math inline">\(i_1,…,i_k\)</span> can be seen (in this order and starting from the first one) if and only if both sequences <span class="math inline">\(x_{i_1},…,x_{i_k}\)</span> and <span class="math inline">\(y_{i_1},…,y_{i_k}\)</span> are nondecreasing. To see this, observe that <span class="math display">\[x_i≤x_j⟺vt_i−a_i≤vt_j−a_j⟺a_j−a_i≤v(t_j−t_i)\]</span></p><p>and <span class="math display">\[y_i≤y_j⟺vt_i+a_i≤vt_j+a_j⟺a_i−a_j≤v(t_j−t_i)\]</span> Moreover <span class="math display">\[t_i=\frac{x_i+y_i}{2v}\]</span> so if both sequences are nondecreasing, then their corresponding times are in increasing order and it holds that <span class="math inline">\(|a_{i_ℓ}+1−a_{i_ℓ}|≤v(t_{i_ℓ}+1−t_{i_ℓ})\)</span>, which means that each event can be reached from the previous one. The converse is clear from the previous inequalities.</p><p>In order to impose the condition that the events can be reached starting from position 00 at time 00, it is enough to remove all points which cannot be reached from the origin, that is, with <span class="math inline">\(|ai|&gt;vti\)</span>. We will assume that these events have been eliminated and still denote by <span class="math inline">\(n\)</span> the total number of events.</p><p>We have thus reduced the problem to finding the longest increasing subsequence of the <span class="math inline">\(y\)</span>-values when ordered by increasing xx-value. More precisely, let <span class="math inline">\((p_1,…,p_n)\)</span> be the permutation of <span class="math inline">\((1,…,n)\)</span> such that</p><p><span class="math inline">\(i&lt;j⟹x_{p_i}&lt;x_{p_j}\ \text{or}\ (x_{p_i}=x_{p_j}\ \text{and}\ y_{p_i}&lt;y_{p_j})\)</span>.</p><p>Then the solution of the problem is the length of the longest (non-strictly) increasing subsequence of the list <span class="math inline">\(y_{p_1},…,y_{p_n}\)</span>.</p><p>There are classical algorithms to solve this efficiently in <span class="math inline">\(O(n\log n)\)</span> time. For instance, this complexity is achieved by an approach that processes the elements from left to right and uses binary searches to update the value of the smallest possible last element of a length-<span class="math inline">\(k\)</span> increasing subsequence in every prefix for every <span class="math inline">\(k\)</span>.</p><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200005</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll t[N],a[N],n,v,nn;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;ll x,y;&#125;_[N];<br>ll dp[N],u;<br><span class="hljs-type">int</span> top;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i])&lt;=v*t[i])_[++nn]=&#123;t[i]*v+a[i],t[i]*v-a[i]&#125;;n=nn;<br><span class="hljs-built_in">sort</span>(_+<span class="hljs-number">1</span>,_+<span class="hljs-number">1</span>+n,[](A a,A b)&#123;<span class="hljs-keyword">return</span> a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;);<span class="hljs-comment">//lambda</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>((u=_[i].y)&gt;=dp[top])dp[++top]=u;<br><span class="hljs-keyword">else</span> dp[<span class="hljs-built_in">upper_bound</span>(dp+<span class="hljs-number">1</span>,dp+<span class="hljs-number">1</span>+top,u)-dp]=u;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,top);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1662I</title>
    <link href="/2022/05/30/CF1662I/"/>
    <url>/2022/05/30/CF1662I/</url>
    
    <content type="html"><![CDATA[<p>[[implementation]] <a href="https://codeforces.com/problemset/problem/1662/I">link</a></p><p>Three cases:</p><ol type="1"><li>The leftmost</li><li>In the middle</li><li>The rightmost</li></ol><p>In the sides, we can get everyone.</p><p>In the middle, we can only get people in a range of the half of the distance between the nearest shops. Use two pointers.</p><p>Although the process is simple, the code is full of details.</p><h3 id="code">Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200005</span>;<br><span class="hljs-type">int</span> n,m,p[N],x[N];<br><span class="hljs-type">int</span> range,l,r;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans,an;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;p[i];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)cin&gt;&gt;x[i];<br><span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+m);n--;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n&amp;&amp;i*<span class="hljs-number">100</span>&lt;x[<span class="hljs-number">1</span>];i++)ans+=p[i];<br><span class="hljs-keyword">for</span>(i=x[m]/<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;i&lt;=n;i++)an+=p[i];ans=<span class="hljs-built_in">max</span>(ans,an);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;x[i]&lt;n*<span class="hljs-number">100</span>&amp;&amp;i&lt;m;i++)&#123;<br>range=(x[i+<span class="hljs-number">1</span>]-x[i])/<span class="hljs-number">2</span>/<span class="hljs-number">100</span>;<br>l=r=x[i]/<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(an=<span class="hljs-number">0</span>;r&lt;=n&amp;&amp;r*<span class="hljs-number">100</span>&lt;x[i+<span class="hljs-number">1</span>]&amp;&amp;r-l&lt;=range;r++)an+=p[r];<br>ans=<span class="hljs-built_in">max</span>(ans,an);<br><span class="hljs-keyword">for</span>(;r&lt;=n&amp;&amp;r*<span class="hljs-number">100</span>&lt;x[i+<span class="hljs-number">1</span>];r++,l++)&#123;<br>an-=p[l],an+=p[r];<br>ans=<span class="hljs-built_in">max</span>(ans,an);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1662D</title>
    <link href="/2022/05/30/CF1662D/"/>
    <url>/2022/05/30/CF1662D/</url>
    
    <content type="html"><![CDATA[<p>[[string]] [[thinking]] <a href="https://codeforces.com/problemset/problem/1662/D">link</a></p><p><span class="math inline">\(AA\)</span> <span class="math inline">\(BB\)</span> <span class="math inline">\(ABAB\)</span> <span class="math inline">\(BCBC\)</span> are given, ask whether string <span class="math inline">\(a\)</span> can become string <span class="math inline">\(b\)</span>.</p><p>Inserting and deleting at any position are approved.</p><h2 id="sol">Sol</h2><p>Firstly, the parity of the occurrences of <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> are same in <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p><p>Then, we can transform the string <span class="math inline">\(AB\)</span> to the string <span class="math inline">\(BA\)</span> via the following sequence of moves:</p><blockquote><p>Start with <span class="math inline">\(AB\)</span>, then insert <span class="math inline">\(BB\)</span> at the back of the string to get <span class="math inline">\(ABBB\)</span>, then insert the string <span class="math inline">\(ABAB\)</span> in the second to last position to get <span class="math inline">\(ABBABABB\)</span>.</p><p>Removing the two occurrences of <span class="math inline">\(BB\)</span> we get the string <span class="math inline">\(AABA\)</span> and then removing <span class="math inline">\(AA\)</span> we get to <span class="math inline">\(BA\)</span>.</p></blockquote><p>Similarly, we can transform the string <span class="math inline">\(BC\)</span> to the string <span class="math inline">\(CB\)</span>.</p><p>Therefor, <span class="math inline">\(B\)</span> is movable and their positions are of no great importance.</p><p><span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> is immovable, so I only need to compare the string consist of <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span>.</p><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,la,lb,pa,pb,pc;<br>string a,b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br><span class="hljs-keyword">for</span>(;t--;)&#123;<br>cin&gt;&gt;a&gt;&gt;b;<br>la=a.<span class="hljs-built_in">length</span>();<br>lb=b.<span class="hljs-built_in">length</span>();<br>pa=pb=pc=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;la;i++)&#123;<br><span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;A&#x27;</span>)pa^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;B&#x27;</span>)pb^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;C&#x27;</span>)pc^=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lb;i++)&#123;<br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-string">&#x27;A&#x27;</span>)pa^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-string">&#x27;B&#x27;</span>)pb^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b[i]==<span class="hljs-string">&#x27;C&#x27;</span>)pc^=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(pa||pb||pc)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;la;i++)<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;B&#x27;</span>)a.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">1</span>),la--,i--;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lb;i++)<span class="hljs-keyword">if</span>(b[i]==<span class="hljs-string">&#x27;B&#x27;</span>)b.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">1</span>),lb--,i--;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;la<span class="hljs-number">-1</span>;i++)<span class="hljs-keyword">if</span>(a[i]==a[i+<span class="hljs-number">1</span>])a.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">2</span>),i=<span class="hljs-built_in">max</span>(<span class="hljs-number">-1</span>,i<span class="hljs-number">-2</span>),la-=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lb<span class="hljs-number">-1</span>;i++)<span class="hljs-keyword">if</span>(b[i]==b[i+<span class="hljs-number">1</span>])b.<span class="hljs-built_in">erase</span>(i,<span class="hljs-number">2</span>),i=<span class="hljs-built_in">max</span>(<span class="hljs-number">-1</span>,i<span class="hljs-number">-2</span>),lb-=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(a==b)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="string-in-stl"><a href="string.md">string in STL</a></h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1201D</title>
    <link href="/2022/05/30/CF1201D/"/>
    <url>/2022/05/30/CF1201D/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] <a href="https://codeforces.com/problemset/problem/1201/D">link</a></p><p>We must visit every single treasure (um, and the coordinate <span class="math inline">\((1,1)\)</span> ,the starting point).</p><p>It's easy to find that the position where you leave is must be the leftmost or the rightmost point.</p><p>Obviously, this is a DP problem.</p><p>A floor has two nodes, but it can only transfer from the last floor, so the states is <span class="math inline">\(dp[2][2]\)</span>.</p><p>Then the most important thing is calculate the cost:</p><blockquote><p>From the lower left to the upper left</p><p>From the lower left to the upper right</p><p>From the lower right to the upper left</p><p>From the lower right to the upper right</p><p>And every point at most has two ladder to move upward, a right and a left.</p><p>And after you move upward, there are two sides you could choose to go, a right and a left as well.</p></blockquote><p>So totally, there are 16 situations.</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">300005</span>,inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n,m,k,q;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">int</span> mi[N],ma[N];<br><span class="hljs-type">int</span> d[N],pre[N],suf[N],pr,su;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>],ans,val[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> t,top;<br><span class="hljs-type">bool</span> b;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> _,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(top=t;!ma[t]&amp;&amp;t&lt;=n;t++);<br><span class="hljs-keyword">if</span>(t==n+<span class="hljs-number">1</span>)&#123;<br>ans=<span class="hljs-built_in">min</span>(dp[b][<span class="hljs-number">0</span>],dp[b][<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,top<span class="hljs-number">-2</span>+ans);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(p&lt;=mi[t])&#123;<br>val[_][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(val[_][<span class="hljs-number">0</span>],inf);<br>val[_][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(val[_][<span class="hljs-number">1</span>],a+ma[t]-p);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&gt;=ma[t])&#123;<br>val[_][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(val[_][<span class="hljs-number">1</span>],inf);<br>val[_][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(val[_][<span class="hljs-number">0</span>],a+p-mi[t]);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>val[_][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(a+ma[t]-p+ma[t]-mi[t],val[_][<span class="hljs-number">0</span>]);<br>val[_][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(a+p-mi[t]+ma[t]-mi[t],val[_][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;q);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)mi[i]=m+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br><span class="hljs-keyword">if</span>(mi[x]&gt;y)mi[x]=y;<br><span class="hljs-keyword">if</span>(ma[x]&lt;y)ma[x]=y;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=q;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x),d[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(d[i])pr=i;<br>pre[i]=pr;<br>&#125;<br>su=m+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=m;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(d[i])su=i;<br>suf[i]=su;<br>&#125;<br><span class="hljs-keyword">if</span>(ma[<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)&#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=ma[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=inf;<br>&#125;<br><span class="hljs-keyword">else</span> mi[<span class="hljs-number">1</span>]=ma[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//&lt;&lt;</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i=t,b^=<span class="hljs-number">1</span>)&#123;<br>t=i+<span class="hljs-number">1</span>;val[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=val[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=val[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=val[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=inf;<br><span class="hljs-keyword">if</span>(suf[mi[i]]!=mi[i]&amp;&amp;pre[mi[i]]!=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">cal</span>(<span class="hljs-number">0</span>,pre[mi[i]],mi[i]-pre[mi[i]]);<br><span class="hljs-keyword">if</span>(suf[mi[i]]!=m+<span class="hljs-number">1</span>)<br><span class="hljs-built_in">cal</span>(<span class="hljs-number">0</span>,suf[mi[i]],suf[mi[i]]-mi[i]);<br><span class="hljs-keyword">if</span>(suf[ma[i]]!=ma[i]&amp;&amp;pre[ma[i]]!=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">cal</span>(<span class="hljs-number">1</span>,pre[ma[i]],ma[i]-pre[ma[i]]);<br><span class="hljs-keyword">if</span>(suf[ma[i]]!=m+<span class="hljs-number">1</span>)<br><span class="hljs-built_in">cal</span>(<span class="hljs-number">1</span>,suf[ma[i]],suf[ma[i]]-ma[i]);<br>dp[b^<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(val[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+dp[b][<span class="hljs-number">0</span>],val[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+dp[b][<span class="hljs-number">1</span>]);<br>dp[b^<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(val[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+dp[b][<span class="hljs-number">0</span>],val[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+dp[b][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1152D</title>
    <link href="/2022/05/30/CF1152D/"/>
    <url>/2022/05/30/CF1152D/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] <a href="https://codeforces.com/contest/1152/problem/D">link</a></p><h2 id="whats-the-max-matching-on-a-tree">What's the max matching on a tree?</h2><p>A simple DP!</p><h2 id="compress-states">Compress states</h2><p>If we draw out the whole trie, well, we'll get <span class="math inline">\(2^{1000}\)</span> nodes. So how could we handle it? We should compress the states.</p><p>Imagine that there is a matrix <span class="math inline">\(A\)</span>. <span class="math inline">\(A_{i,j}\)</span> means there are <span class="math inline">\(i\)</span> '(' edges and <span class="math inline">\(j\)</span> ')' edges on the path from this node to the root. (which also means there are <span class="math inline">\(n-i\)</span> '(' edges and <span class="math inline">\(n-j\)</span> ')' edges on the path from this node to the leaves) <em>PS: Cause we must make the bracket sequences correct, <span class="math inline">\(i\)</span> must bigger than <span class="math inline">\(j\)</span>.</em></p><p>Than move the DP on trees to matrix.</p><h1 id="the-state-transfer-equation-is">The state transfer equation is:</h1><p><span class="math display">\[\begin{align*}&amp;f[i][j]=\begin{cases}g[i+1][j]+max(g[i][j+1],f[i][j+1])+1, &amp;g[i+1]&gt;g[i][j+1]\\g[i][j+1]+max(g[i+1][j],f[i+1][j])+1, &amp;g[i+1]&lt;=g[i][j+1]\\\end{cases}\\&amp;g[i][j]=max(f[i+1][j],g[i+1][j])+max(g[i][j+1],f[i][j+1])\end{align*}\]</span></p><p><span class="math inline">\(f[i][j]\)</span> is the state that this node have a match edge to his children.</p><p><span class="math inline">\(g[i][j]\)</span> haven't.</p><h1 id="code">CODE:</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1003</span>,M=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> f[N][N],g[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);n++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=i;j--)&#123;<br><span class="hljs-keyword">if</span>(i==j)&#123;<br>f[i][j]=g[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>g[i][j]=<span class="hljs-built_in">max</span>(g[i][j+<span class="hljs-number">1</span>],f[i][j+<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n)&#123;<br>f[i][j]=g[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>;<br>g[i][j]=<span class="hljs-built_in">max</span>(g[i+<span class="hljs-number">1</span>][j],f[i+<span class="hljs-number">1</span>][j]);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(g[i+<span class="hljs-number">1</span>][j]&gt;g[i][j+<span class="hljs-number">1</span>])f[i][j]=(g[i+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">max</span>(g[i][j+<span class="hljs-number">1</span>],f[i][j+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>)%M;<br><span class="hljs-keyword">else</span> f[i][j]=(g[i][j+<span class="hljs-number">1</span>]+<span class="hljs-built_in">max</span>(g[i+<span class="hljs-number">1</span>][j],f[i+<span class="hljs-number">1</span>][j])+<span class="hljs-number">1</span>)%M;<br>g[i][j]=(<span class="hljs-built_in">max</span>(f[i+<span class="hljs-number">1</span>][j],g[i+<span class="hljs-number">1</span>][j])+<span class="hljs-built_in">max</span>(g[i][j+<span class="hljs-number">1</span>],f[i][j+<span class="hljs-number">1</span>]))%M;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF959D</title>
    <link href="/2022/05/30/CF959D/"/>
    <url>/2022/05/30/CF959D/</url>
    
    <content type="html"><![CDATA[<p>[[math]] <a href="https://codeforces.com/problemset/problem/959/D">link</a></p><blockquote><ul><li><span class="math inline">\(b\)</span> is lexicographically greater than or equal to <span class="math inline">\(a\)</span>.</li><li><span class="math inline">\(b_i ≥2\)</span>.</li><li><span class="math inline">\(b\)</span> is pairwise coprime: for every <span class="math inline">\(1 ≤ i &lt; j ≤ n\)</span>, <span class="math inline">\(b_i\)</span> and <span class="math inline">\(b_j\)</span> are coprime</li></ul></blockquote><p>If <span class="math inline">\(i&lt;j,b_i&gt;b_j\)</span>, <span class="math inline">\(b\)</span> is lexicographically greater than or equal to <span class="math inline">\(a\)</span>, then swap <span class="math inline">\(b_i\)</span> and <span class="math inline">\(b_j\)</span>, the set of numbers of <span class="math inline">\(b\)</span> is the same.</p><p>Therefore, <span class="math inline">\(b\)</span> is increasing. Every time we choose the number of <span class="math inline">\(b_i\)</span>, must choose the minimum value that meets the condition.</p><p>So, what the requirement means?</p><p>First, <span class="math inline">\(b_i=a_i\)</span>, until <span class="math inline">\(b_i\)</span> can't equal to <span class="math inline">\(a_i\)</span>, must bigger.(<span class="math inline">\(\gcd(b_i,a_j)!=1, j&lt;i\)</span>) We can reach that by sieve method.</p><p>Later, we don't need to care about lexicographically greater, which means we don't need to care about <span class="math inline">\(a\)</span>.</p><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2000000</span>;<br><span class="hljs-type">int</span> n,a,aa,b,v[N+<span class="hljs-number">5</span>],f,P[N];<br>set&lt;<span class="hljs-type">int</span>&gt; p;<br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=N;i+=x)<span class="hljs-keyword">if</span>(!v[i])v[i]=<span class="hljs-number">1</span>,p.<span class="hljs-built_in">erase</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)&#123;<br>p.<span class="hljs-built_in">insert</span>(i);<br><span class="hljs-keyword">if</span>(!v[i])P[++P[<span class="hljs-number">0</span>]]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=P[<span class="hljs-number">0</span>]&amp;&amp;i*P[j]&lt;=N;j++)&#123;<br>v[i*P[j]]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(i%P[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> v);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=n;o++)&#123;<br>b=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br><span class="hljs-keyword">if</span>(f)it=p.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">else</span>&#123;<br>it=p.<span class="hljs-built_in">lower_bound</span>(a);<br><span class="hljs-keyword">if</span>(*it!=a)f=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>aa=a=*it;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;P[i]*P[i]&lt;=aa;i++)&#123;<br><span class="hljs-keyword">if</span>(a%P[i]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(!v[P[i]])<span class="hljs-built_in">update</span>(P[i]);<br><span class="hljs-keyword">for</span>(;a%P[i]==<span class="hljs-number">0</span>;a/=P[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(a!=<span class="hljs-number">1</span>&amp;&amp;!v[a])<span class="hljs-built_in">update</span>(a);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF894B</title>
    <link href="/2022/05/30/CF894B/"/>
    <url>/2022/05/30/CF894B/</url>
    
    <content type="html"><![CDATA[<p>[[math]] <a href="https://codeforces.com/problemset/problem/894/B">link</a></p><p>First, it's obvious that the numbers put can be only 1 or -1.</p><p>If k equals to -1 and the parity of n and m differ, the answer is obviously 0.</p><blockquote><p>Assume that <span class="math inline">\(n\)</span> is even and <span class="math inline">\(m\)</span> is even, the count of -1 equals to <span class="math inline">\(n*odd\)</span> (even) and <span class="math inline">\(m*odd\)</span> (odd), and it is impassible to be odd and even at the same time.</p></blockquote><p>Otherwise, for the first n-1 lines and the first m-1 columns, we can put either 1 or -1 in it, and there're <span class="math inline">\(2^{(n - 1) * (m-1)}\)</span> ways in total.</p><p>Then it's obvious that the remaining numbers are uniquely determined because the product of each row and each column is known already.</p><p>So in this case the answer is <span class="math inline">\(2^{(n - 1) * (m-1)}\)</span> .</p><p>We can use fast power, which is easy.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll n,m,ret;<br><span class="hljs-type">int</span> k;<br><span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(ret=<span class="hljs-number">1</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(a&amp;<span class="hljs-number">1</span>)(ret*=x)%=mod;<br>(x*=x)%=mod;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br><span class="hljs-keyword">if</span>(!~k&amp;&amp;(n&amp;<span class="hljs-number">1</span>)!=(m&amp;<span class="hljs-number">1</span>))<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>),<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">fp</span>(<span class="hljs-built_in">fp</span>(<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>),m<span class="hljs-number">-1</span>));<br>&#125; <br></code></pre></td></tr></table></figure><p>(If the code is very long, I'll leave a link.)</p><p>2022.3.28</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF869D</title>
    <link href="/2022/05/30/CF869D/"/>
    <url>/2022/05/30/CF869D/</url>
    
    <content type="html"><![CDATA[<p>[[dfs]] [[trees_and_similar]] <a href="https://codeforces.com/problemset/problem/869/D">link</a></p><p>At first, I felt confused about the description.</p><p>calculate the number of simple paths in a completed binary tree with a few extra edges? n&lt;1e9!?</p><p>O(n) is unacceptable.</p><p>Then, I tried to compress the nodes. But after I compressed them, I have way to calculate the number of simple paths.</p><p>I've read the tutorial.</p><h2 id="how-to-compress-a-tree-with-only-a-few-extra-edges">How to compress a tree with only a few extra edges?</h2><p>With one extra edge? 基环树。</p><p>What about more edge? 多环树？Name isn't important.</p><p>Find out the graph consisting of cycles.</p><p>Every node can represent the tree below it, so the small tree is able to be compressed to the root.</p><hr><p>At last, calculate the number of simple paths is a simple dfs problem.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500</span>,M=<span class="hljs-number">2000</span>,mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,h[N],nxt[M],to[M],t,a,b;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>nxt[++t]=h[u],h[u]=t,to[t]=v;<br>nxt[++t]=h[v],h[v]=t,to[t]=u;<br>&#125;<br><span class="hljs-type">int</span> it;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;I;<br><span class="hljs-type">int</span> vis[N];<br>[[define]] pb push_back<br><span class="hljs-type">int</span> d,rem;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-type">int</span> l,r,_=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(it=u;it;_++,it&gt;&gt;=<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(it=u;(it&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)&lt;=n;it=it&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);r=it;<br><span class="hljs-keyword">for</span>(it=u;(it&lt;&lt;<span class="hljs-number">1</span>)&lt;=n;it=it&lt;&lt;<span class="hljs-number">1</span>);l=it;<br><span class="hljs-keyword">if</span>(r&gt;n-rem)<span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;d-_+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&lt;=n-rem)<span class="hljs-built_in">return</span> (<span class="hljs-number">1</span>&lt;&lt;d-_)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (<span class="hljs-number">1</span>&lt;&lt;d-_)+n-l;<br>&#125;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tot,ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>vis[u]=<span class="hljs-number">1</span>;tot+=num[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[u],v;e;e=nxt[e])<br><span class="hljs-keyword">if</span>(!vis[v=to[e]])<span class="hljs-built_in">dfs</span>(v);<br>vis[u]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> x[<span class="hljs-number">5</span>],y[<span class="hljs-number">5</span>],u,v;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!I[num])I[num]=I.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">return</span> I[num];<br>&#125;<br><span class="hljs-type">int</span> fa;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-number">1ll</span>*n*n%mod);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(it=n;it;it&gt;&gt;=<span class="hljs-number">1</span>)d++;<br>rem=n-(<span class="hljs-number">1</span>&lt;&lt;d<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);<br><span class="hljs-keyword">for</span>(it=x[i];it;it&gt;&gt;=<span class="hljs-number">1</span>)<span class="hljs-built_in">id</span>(it);<br><span class="hljs-keyword">for</span>(it=y[i];it;it&gt;&gt;=<span class="hljs-number">1</span>)<span class="hljs-built_in">id</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:I)<span class="hljs-keyword">if</span>(p.first!=<span class="hljs-number">1</span>)<span class="hljs-built_in">add</span>(p.second,I[p.first&gt;&gt;<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:I)num[p.second]=<span class="hljs-built_in">cal</span>(p.first);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:I)&#123;<br>fa=I[p.first&gt;&gt;<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[u=p.second];e;e=nxt[e])<br><span class="hljs-keyword">if</span>(!vis[v=to[e]]&amp;&amp;v!=fa)<br>num[u]-=num[v],vis[v]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-built_in">add</span>(I[x[i]],I[y[i]]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:I)&#123;<br>tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(p.second);<br>ans=(ans+tot*num[p.second]%mod)%mod;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF862D</title>
    <link href="/2022/05/30/CF862D/"/>
    <url>/2022/05/30/CF862D/</url>
    
    <content type="html"><![CDATA[<p>[[interactive]] [[divide_and_conquer]] <a href="https://codeforces.com/problemset/problem/862/D">link</a></p><p>We are allowed to query 15 times, and n&lt;1000. Obviously, use ==divide and conquer== algorithm.</p><h3 id="a-small-conclusion">A small conclusion</h3><p>Make <span class="math inline">\(h(1,n)\)</span> represent the Hamming distance from 1 to n.</p><p>x is the number before altering, y is after.</p><p>We change 0/1 within the range of 1~mid. <span class="math display">\[\begin{cases}&amp;x=h(1,n)=h(1,m)+h(m+1,r)\\&amp;y=h&#39;(1,m)+h(m+1,r)=(m-l+1-h(1,m))+h(m+1,r)\\\end{cases}\\\iff\\\begin{cases}&amp;h(l,m)=(x-y-(m-l+1))/2\\&amp;h(m+1,r)=(x+y+(m-l+1))/2\end{cases}\]</span></p><hr><p>Then, we can use <span class="math inline">\(h1[2]\)</span>, <span class="math inline">\(h2[2]\)</span> to represent the number of number 0 or 1 in two sides.</p><p>If one side is full of 1 or full of 0. The next goal is to find the another number in the other side.</p><p>If both sides have 1 and 0, choose either side to continue to divide and conquer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,o[<span class="hljs-number">1003</span>],h1[<span class="hljs-number">2</span>],h2[<span class="hljs-number">2</span>],x[<span class="hljs-number">2</span>],y,h;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;? &quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,o[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;! %d %d&quot;</span>,ans[<span class="hljs-number">0</span>],ans[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">to1</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span></span>&#123;<br>x[<span class="hljs-number">0</span>]=h1[<span class="hljs-number">0</span>],x[<span class="hljs-number">1</span>]=h1[<span class="hljs-number">1</span>];<br>h+=h2[f];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">to2</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span></span>&#123;<br>x[<span class="hljs-number">0</span>]=h2[<span class="hljs-number">0</span>],x[<span class="hljs-number">1</span>]=h2[<span class="hljs-number">1</span>];<br>h+=h1[f^<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=m;i++)o[i]=f;<br><span class="hljs-built_in">print</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>y-=h;<br>h1[f]=(x[f]-y+(m-l+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;<span class="hljs-comment">//the number of f</span><br>h1[f^<span class="hljs-number">1</span>]=m-l+<span class="hljs-number">1</span>-h1[f];<br>h2[f]=(x[f]+y-(m-l+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;<br>h2[f^<span class="hljs-number">1</span>]=r-m-h2[f];<br><span class="hljs-keyword">if</span>(!ans[<span class="hljs-number">0</span>]&amp;&amp;!ans[<span class="hljs-number">1</span>])&#123;<br><span class="hljs-keyword">if</span>(h1[f]==m-l+<span class="hljs-number">1</span>||h1[f]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(h1[f]==m-l+<span class="hljs-number">1</span>)ans[f]=l;<br><span class="hljs-keyword">if</span>(h1[f]==<span class="hljs-number">0</span>)ans[f^<span class="hljs-number">1</span>]=l;<br><span class="hljs-built_in">to2</span>(f);<span class="hljs-built_in">dc</span>(m+<span class="hljs-number">1</span>,r,f);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(h2[f]==r-m)ans[f]=r;<br><span class="hljs-keyword">if</span>(h2[f]==<span class="hljs-number">0</span>)ans[f^<span class="hljs-number">1</span>]=r;<br><span class="hljs-built_in">to1</span>(f);<span class="hljs-built_in">dc</span>(l,m,f^<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)<span class="hljs-keyword">if</span>(!ans[i])&#123;<br><span class="hljs-keyword">if</span>(h1[i]==m-l+<span class="hljs-number">1</span>)ans[i]=l,<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">if</span>(h2[i]==r-m)ans[i]=r,<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">if</span>(!h1[i])<span class="hljs-built_in">to2</span>(f),<span class="hljs-built_in">dc</span>(m+<span class="hljs-number">1</span>,r,f);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">to1</span>(f),<span class="hljs-built_in">dc</span>(l,m,f^<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">print</span>();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x[<span class="hljs-number">1</span>]);x[<span class="hljs-number">0</span>]=n-x[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">dc</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF814D</title>
    <link href="/2022/05/30/CF814D/"/>
    <url>/2022/05/30/CF814D/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] <a href="https://codeforces.com/problemset/problem/814/D">link</a></p><p>The circles are shaped like a tree(or forest).</p><p>n&lt;1000, consider DP.</p><p>We can find that if the parity of both sides is fixed, whether the next number is - or + is fixed.</p><p>By this way, we can use <span class="math inline">\(u\)</span>,<span class="math inline">\(0/1\)</span>,<span class="math inline">\(0/1\)</span> as the state. <span class="math display">\[g[i][j]=f[v][i][j]\\f[u][i][j]=max\begin{cases}g[i\oplus1][j]+val[u]*(i==0?1:-1)\\g[i][j\oplus1]+val[u]*(j==0?1:-1)\end{cases}\]</span> We must control the plus or minus sign by hand, so that the area can be right.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1003</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">O</span>&#123;<br>ll x,y,r;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> O&amp;a)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> r&lt;a.r;&#125;<br>&#125;nd[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x(i) nd[i].x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y(i) nd[i].y</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> r(i) nd[i].r</span><br>vector&lt;<span class="hljs-type">int</span>&gt;e[N];<br><span class="hljs-type">int</span> que[N],l,r,fa[N],u;<br>ll f[N][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>],g[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>],ans;<span class="hljs-comment">//0-&gt;odd 1-&gt;even</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">int</span> deg[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;<span class="hljs-built_in">x</span>(i),&amp;<span class="hljs-built_in">y</span>(i),&amp;<span class="hljs-built_in">r</span>(i));<br><span class="hljs-built_in">sort</span>(nd+<span class="hljs-number">1</span>,nd+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(e[i].<span class="hljs-built_in">empty</span>())que[++r]=i;<br><span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">if</span>((<span class="hljs-built_in">x</span>(i)-<span class="hljs-built_in">x</span>(j))*(<span class="hljs-built_in">x</span>(i)-<span class="hljs-built_in">x</span>(j))+(<span class="hljs-built_in">y</span>(i)-<span class="hljs-built_in">y</span>(j))*(<span class="hljs-built_in">y</span>(i)-<span class="hljs-built_in">y</span>(j))&lt;<span class="hljs-built_in">r</span>(j)*<span class="hljs-built_in">r</span>(j))&#123;<br>fa[i]=j,e[j].<span class="hljs-built_in">push_back</span>(i),deg[j]++;<span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">1</span>;l&lt;=r;l++)&#123;<br><span class="hljs-keyword">if</span>(fa[u=que[l]]&amp;&amp;--deg[fa[u]]==<span class="hljs-number">0</span>)que[++r]=fa[u];<br>g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=g[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=g[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])<br>g[i][j]+=f[v][i][j]; <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)<br>f[u][i][j]=<span class="hljs-built_in">max</span>(g[i^<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">r</span>(u)*<span class="hljs-built_in">r</span>(u)*(i==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>),g[i][j^<span class="hljs-number">1</span>]+<span class="hljs-built_in">r</span>(u)*<span class="hljs-built_in">r</span>(u)*(j==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>));<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(!fa[i])ans+=f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8lf&quot;</span>,ans*Pi);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF814C</title>
    <link href="/2022/05/30/CF814C/"/>
    <url>/2022/05/30/CF814C/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] <a href="https://codeforces.com/contest/814/problem/C">link</a></p><p>How stupid of me! I couldn't find the possible time complexity at the first time. Just look at the data range, <span class="math inline">\(n&lt;1500\)</span>, <span class="math inline">\(q&lt;200000\)</span>. Obviously, <span class="math inline">\(O(nq)\)</span> is impossible, but I thought about it for a long time.</p><p>Maybe <span class="math inline">\(O(n^2+q)\)</span>?</p><p>We need O(1) query, so we must store every possible query.</p><p>Use DP(dynamic programming).</p><p>Optimizing to 2D (without <span class="math inline">\(|\Sigma|\)</span>) is possible, but not necessary.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,q,ans[<span class="hljs-number">26</span>][<span class="hljs-number">2003</span>],cost[<span class="hljs-number">26</span>],x;<br><span class="hljs-type">char</span> o[<span class="hljs-number">2003</span>],c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;o+<span class="hljs-number">1</span>&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">memset</span>(cost,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> cost);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++)&#123;<br><span class="hljs-keyword">if</span>(k==o[j]-<span class="hljs-string">&#x27;a&#x27;</span>)cost[k]++;<br>ans[k][j-i+<span class="hljs-number">1</span>-cost[k]]=<span class="hljs-built_in">max</span>(j-i+<span class="hljs-number">1</span>,ans[k][j-i+<span class="hljs-number">1</span>-cost[k]]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">26</span>;x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ans[x][i]=<span class="hljs-built_in">max</span>(ans[x][i],ans[x][i<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(;q--;cin&gt;&gt;x&gt;&gt;c,<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[c-<span class="hljs-string">&#x27;a&#x27;</span>][x]));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF811D</title>
    <link href="/2022/05/30/CF811D/"/>
    <url>/2022/05/30/CF811D/</url>
    
    <content type="html"><![CDATA[<p>[[interactive]] [[shortest_path]] <a href="https://codeforces.com/problemset/problem/811/D">link</a></p><p>An interactive problem, we need use <code>fflush(stdout);</code></p><p>First, find a path to the destination, using BFS.</p><p>Then, hit the wall or "lose" for less than two times to update the right direction.</p><p>Finally, walk to the destination.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,x,y,xx,yy,cnt,a[<span class="hljs-number">102</span>][<span class="hljs-number">102</span>],way[<span class="hljs-number">20004</span>];<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">int</span> que[<span class="hljs-number">10004</span>][<span class="hljs-number">2</span>],l,r,vis[<span class="hljs-number">102</span>][<span class="hljs-number">102</span>],dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,ret[<span class="hljs-number">102</span>][<span class="hljs-number">102</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;c;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;F&#x27;</span>)a[i][j]=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;*&#x27;</span>)a[i][j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">100</span>;i++)vis[<span class="hljs-number">0</span>][i]=vis[i][<span class="hljs-number">0</span>]=vis[n+<span class="hljs-number">1</span>][i]=vis[i][m+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>que[l][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,que[l][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;vis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(;l&lt;=r;l++)&#123;<br>x=que[l][<span class="hljs-number">0</span>],y=que[l][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-number">2</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-keyword">if</span>(!vis[xx=x+dx[i]][yy=y+dy[i]]&amp;&amp;a[xx][yy]!=<span class="hljs-number">1</span>)&#123;<br>ret[xx][yy]=i;<br>que[++r][<span class="hljs-number">0</span>]=xx;<br>que[r][<span class="hljs-number">1</span>]=yy;<br>vis[xx][yy]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">1</span>||y!=<span class="hljs-number">1</span>;)&#123;<br>way[cnt++]=ret[x][y];<br>xx=x;yy=y;<br>x-=dx[ret[xx][yy]];<br>y-=dy[ret[xx][yy]];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cnt<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;j&lt;i;j++,i--)&#123;<br><span class="hljs-built_in">swap</span>(way[i],way[j]);<br>&#125;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">4</span>]=&#123;<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>x=y=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>cout&lt;&lt;ch[way[i]]&lt;&lt;endl;<br><span class="hljs-built_in">fflush</span>(stdout);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;xx,&amp;yy);<br><span class="hljs-keyword">if</span>(x+dx[way[i]]!=xx||y+dy[way[i]]!=yy)&#123;<br><span class="hljs-built_in">swap</span>(ch[way[i]],ch[way[i]^<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span>((xx!=x||yy!=y)&amp;&amp;(xx!=<span class="hljs-number">-1</span>||yy!=<span class="hljs-number">-1</span>))<br>cout&lt;&lt;ch[way[i]]&lt;&lt;endl,<span class="hljs-built_in">fflush</span>(stdout),<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>cout&lt;&lt;ch[way[i]]&lt;&lt;endl,<span class="hljs-built_in">fflush</span>(stdout),<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>&#125;<br><span class="hljs-keyword">else</span> x+=dx[way[i]],y+=dy[way[i]];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF776D</title>
    <link href="/2022/05/30/CF776D/"/>
    <url>/2022/05/30/CF776D/</url>
    
    <content type="html"><![CDATA[<p>[[2-sat]] <a href="http://codeforces.com/problemset/problem/776/D">link</a></p><p>The most important information is that each door is controlled by <strong>exactly two</strong> switches.</p><p>If this door is closed, If the first switch is selected, then the second switch must can't be selected,</p><p>​ If the first switch isn't selected, then the second switch must be selected.</p><p>If this door is on, If the first switch is selected, then the second switch must be selected,</p><p>​ If the first switch isn't selected, then the second switch must can't be selected.</p><p>Use <strong>2-sat</strong>.</p><p>Divide a switch into two nodes.</p><p>A node means if select this switch, another means if don't select this switch.</p><p>Then put it down, if you must to do it.</p><p>If meet something wrong (you must select and must can't select a switch in the same time), print NO.</p><p>If everything is ok, print YES.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> a,n,m,l[N],link[<span class="hljs-number">2</span>][N],o,t;<br><span class="hljs-type">int</span> h[N&lt;&lt;<span class="hljs-number">1</span>],to[N&lt;&lt;<span class="hljs-number">2</span>],nxt[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>nxt[++t]=h[u],h[u]=t,to[t]=v;<br>nxt[++t]=h[v],h[v]=t,to[t]=u;<br>&#125;<br><span class="hljs-type">int</span> vis[N&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(vis[u^<span class="hljs-number">1</span>])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>vis[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[u];e;e=nxt[e])<br><span class="hljs-keyword">if</span>(!vis[to[e]]&amp;&amp;!<span class="hljs-built_in">dfs</span>(to[e]))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;l[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;o);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=o;j++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br><span class="hljs-keyword">if</span>(link[<span class="hljs-number">0</span>][a])link[<span class="hljs-number">1</span>][a]=i*<span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> link[<span class="hljs-number">0</span>][a]=i*<span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(l[i])&#123;<br><span class="hljs-built_in">add</span>(link[<span class="hljs-number">0</span>][i],link[<span class="hljs-number">1</span>][i]);<br><span class="hljs-built_in">add</span>(link[<span class="hljs-number">0</span>][i]^<span class="hljs-number">1</span>,link[<span class="hljs-number">1</span>][i]^<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">add</span>(link[<span class="hljs-number">0</span>][i]^<span class="hljs-number">1</span>,link[<span class="hljs-number">1</span>][i]);<br><span class="hljs-built_in">add</span>(link[<span class="hljs-number">0</span>][i],link[<span class="hljs-number">1</span>][i]^<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">if</span>(!vis[i*<span class="hljs-number">2</span>]&amp;&amp;!vis[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]&amp;&amp;!<span class="hljs-built_in">dfs</span>(i*<span class="hljs-number">2</span>))<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO&quot;</span>),<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF761C</title>
    <link href="/2022/05/30/CF761C/"/>
    <url>/2022/05/30/CF761C/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] <a href="https://codeforces.com/problemset/problem/761/C">link</a></p><p>First, calc three numbers about i-th string which mean the shortest distance to '#' '*' '&amp;', number and letter.</p><p>Then, use DP.</p><p>The DP transfer equation is: <span class="math display">\[\begin{aligned}&amp;dp[1][0][0][i]=dp[1][0][0][i-1]+da[i][0]\\&amp;dp[0][1][0][i]=dp[0][1][0][i-1]+da[i][1]\\ &amp;dp[0][0][1][i]=dp[0][0][1][i-1]+da[i][2]\\&amp;dp[1][1][0][i]=min\begin{cases}dp[1][1][0][i-1]+min(da[i][0],da[i][1])\\dp[1][0][0][i-1]+da[i][1]\\dp[0][1][0][i-1]+da[i][0]\end{cases}\\&amp;dp[0][1][1][i]=min\begin{cases}dp[0][1][1][i-1]+min(da[i][1],da[i][2])\\dp[0][1][0][i-1]+da[i][2]\\dp[0][0][1][i-1]+da[i][1]\end{cases}\\&amp;dp[1][0][1][i]=min\begin{cases}dp[1][0][1][i-1]+min(da[i][0],da[i][2])\\dp[1][0][0][i-1]+da[i][2]\\dp[0][0][1][i-1]+da[i][0]\end{cases}\\&amp;dp[1][1][1][i]=min\begin{cases}dp[1][1][1][i-1]+min(da[i][0],min(da[i][1],da[i][2]))\\dp[1][1][0][i-1]+da[i][2]\\dp[1][0][1][i-1]+da[i][1]\\dp[0][1][1][i-1]+da[i][0]\end{cases}\end{aligned}\]</span> Every bit stores whether this kind of characters has appeared.</p><p>That's all.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">55</span>],da[<span class="hljs-number">55</span>][<span class="hljs-number">3</span>],l,r;<br><span class="hljs-type">char</span> a[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isn</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isc</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> c==<span class="hljs-string">&#x27;#&#x27;</span>||c==<span class="hljs-string">&#x27;&amp;&#x27;</span>||c==<span class="hljs-string">&#x27;*&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isa</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isn</span>(a[i][<span class="hljs-number">1</span>]))&#123;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">2</span>,r=m;l&lt;=r;l++,r--)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isn</span>(a[i][l])||<span class="hljs-built_in">isn</span>(a[i][r]))&#123;<br>da[i][<span class="hljs-number">0</span>]=l<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(l&gt;r)da[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1e3</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isc</span>(a[i][<span class="hljs-number">1</span>]))&#123;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">2</span>,r=m;l&lt;=r;l++,r--)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isc</span>(a[i][l])||<span class="hljs-built_in">isc</span>(a[i][r]))&#123;<br>da[i][<span class="hljs-number">1</span>]=l<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(l&gt;r)da[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1e3</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isa</span>(a[i][<span class="hljs-number">1</span>]))&#123;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">2</span>,r=m;l&lt;=r;l++,r--)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isa</span>(a[i][l])||<span class="hljs-built_in">isa</span>(a[i][r]))&#123;<br>da[i][<span class="hljs-number">2</span>]=l<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(l&gt;r)da[i][<span class="hljs-number">2</span>]=<span class="hljs-number">1e3</span>;<br>&#125;<br>&#125;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=da[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=da[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=da[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1e3</span>;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1e3</span>;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1e3</span>;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1e3</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i]=dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">2</span>];<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i]=<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(da[i][<span class="hljs-number">0</span>],da[i][<span class="hljs-number">1</span>]),<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">0</span>]));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][i]=<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(da[i][<span class="hljs-number">1</span>],da[i][<span class="hljs-number">2</span>]),<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">2</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">1</span>]));<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i]=<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(da[i][<span class="hljs-number">0</span>],da[i][<span class="hljs-number">2</span>]),<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">2</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">0</span>]));<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][i]=<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(da[i][<span class="hljs-number">0</span>],<span class="hljs-built_in">min</span>(da[i][<span class="hljs-number">1</span>],da[i][<span class="hljs-number">2</span>])),<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">2</span>],<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+da[i][<span class="hljs-number">0</span>])));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][n]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF711E</title>
    <link href="/2022/05/30/CF711E/"/>
    <url>/2022/05/30/CF711E/</url>
    
    <content type="html"><![CDATA[<p>[[math]] [[combinatorics]] [[inverse_element]] <a href="https://codeforces.com/problemset/problem/711/E">link</a></p><h2 id="the-tutorial-on-cf">The tutorial on CF</h2><p>Note that <em>MOD</em>=10<sup>6</sup>+3 is a prime.</p><p>Firstly, if we have <span class="math inline">\(k &gt; 2^n\)</span>, then by pigeonhole principle(鸽笼原理) we must have 2 people with the same birthday. Thus, we can directly output 1 1.</p><p>Thus, now we suppose <span class="math inline">\(k \le 2^n\)</span>. Then, instead of computing the probability directly, we compute the complement, i.e. the probability that all the people have distinct birthdays. This probability <code>turns out</code> to be much simpler to calculate, as it is just ==<span class="math inline">\(\frac{(2^n-1)*(2^n-2)...(2^n-(k-1))}{2^{(k-1)n}}\)</span>==. (Fix the birthday of the first person, the probability that the second person has different birthday is <span class="math inline">\(\frac{2^n-1}{2^n}\)</span>, and for the next person it's <span class="math inline">\(\frac{2^n-2}{2^n}\)</span> and so on.)</p><p>Now, we know that the denominator is just a power of 2. However, we still have to reduce the fraction to the lowest terms. Note that <span class="math inline">\(\frac{a}{b}\)</span> is in the lowest terms if and only if <span class="math inline">\(1-\frac{a}{b}=\frac{b-a}{b}\)</span> is in the lowest terms,since <span class="math inline">\(gcd(a,b)=gcd(b-a,b)\)</span> . Also, note that the gcd is a power of 2 since the denominator is a power of 2. Thus, we need to find the highest power of 2 that divides (2<em>n</em> - 1)(2<em>n</em> - 2)...(2<em>n</em> - (<em>k</em> - 1)). This is also equal to the sum of the highest power of 2 that divides 2n-1, 2n-2, ..., 2n-(k-1).</p><p>Now, ==if a power of 2 divides <em>x</em> &lt; 2<sup>n</sup>, then it must also divides 2<sup>n</sup> - <em>x</em> and vice versa.== So, we can actually translate this to finding the sum of highest power of 2 that divides 1, 2, ..., <em>k</em> - 1, or the highest power of 2 that divides (<em>k</em> - 1)! . Now, this is simple to calculate by Legendre's formula (which is quite easy to prove) in <span class="math inline">\(O(log k)\)</span>.</p><p>Now that we find the gcd of the numerator and denominator, we can immediately find the reduced denominator by binary exponentiation. For the numerator, we need a bit more work, since we have to deal with (2<em>n</em> - 1)(2<em>n</em> - 2)...(2<em>n</em> - (<em>k</em> - 1)). However, it is not hard either. The key fact is that <em>MOD</em> is small, so if <em>k</em> - 1 ≥ <em>MOD</em>, the product above is equal to 0 modulo <em>MOD</em>, because among <em>MOD</em> consecutive integers there must be one that is a multiple of <em>MOD</em>. Thus, the above product can be calculated in <em>O</em>(<em>MOD</em>) if <em>k</em> - 1 ≤ <em>MOD</em> and <em>O</em>(1) otherwise. The remaining parts can be calculated using direct binary exponentiation.</p><p>One minor note is that when we're calculating 2(<em>k</em> - 1)<em>n</em>, the value of (<em>k</em> - 1)<em>n</em> might overflow. One way to resolve this is to reduce it modulo <em>MOD</em> - 1, since 2<sup>MOD-1</sup> ≡ 1 modulo <em>MOD</em> by Fermat's Little Theorem. Another way is to just evaluate 2<sup>k-1</sup> first, then take the result and raise it to the <em>n</em>-th power.</p><p>Time Complexity : <span class="math inline">\(O(MOD+logk+logn)\)</span></p><h2 id="some-discoveries">Some discoveries</h2><p>The highest power of 2 that divides <span class="math inline">\(n!\)</span> is equal to n subtract the number of 1 in binary form of n.</p><h3 id="legendres-formula">Legendre's formula:</h3><p>在正数n!的素因子标准分解式中，素数p的最高指数 <span class="math display">\[L_p(n!)=\Sigma_{k\ge1}\lfloor\frac{n}{p^k}\rfloor\]</span></p><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>#<span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n,k;<br>ll a,a1,a2,cnt;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1000003</span>;<br>ll res;<br><span class="hljs-function">ll <span class="hljs-title">fpw</span><span class="hljs-params">(ll x,ll a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(res=<span class="hljs-number">1</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>,(x*=x)%=mod)<span class="hljs-keyword">if</span>(a&amp;<span class="hljs-number">1</span>)(res*=x)%=mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>ll den,num;<span class="hljs-comment">//denominator and numerator</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(a=k<span class="hljs-number">-1</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>)cnt++;<br><span class="hljs-keyword">if</span>(n&lt;cnt)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 1&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(a=cnt=k<span class="hljs-number">-1</span>;a;a&gt;&gt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>&amp;a)cnt--;<br>den=<span class="hljs-built_in">fpw</span>(<span class="hljs-built_in">fpw</span>(<span class="hljs-number">2</span>,k<span class="hljs-number">-1</span>),n)*<span class="hljs-built_in">fpw</span>(<span class="hljs-built_in">fpw</span>(<span class="hljs-number">2</span>,mod<span class="hljs-number">-2</span>),cnt)%mod;<br><span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span>&gt;=mod)num=den;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(a=<span class="hljs-built_in">fpw</span>(<span class="hljs-number">2</span>,n),i=num=<span class="hljs-number">1</span>;i&lt;=k<span class="hljs-number">-1</span>;i++)num=(a-i+mod)%mod*num%mod;<br>num=num*<span class="hljs-built_in">fpw</span>(<span class="hljs-built_in">fpw</span>(<span class="hljs-number">2</span>,mod<span class="hljs-number">-2</span>),cnt)%mod;<br>num=den-num&lt;<span class="hljs-number">0</span>?(mod-num+den)%mod:den-num;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>,num,den);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="techniques">Techniques</h1><h2 id="inverse-element">Inverse element</h2><h3 id="way1">Way1</h3><blockquote><h3 id="fermats-little-theorem">Fermat's little theorem</h3><p><span class="math inline">\(p\)</span> is a prime, and <span class="math inline">\(a\)</span> isn't a multiple of <span class="math inline">\(p\)</span>, then <span class="math display">\[a^{p-1}\equiv1 \pmod p\]</span></p></blockquote><p>We can <code>deduce</code> from this that <span class="math display">\[Inv_a=a^{p-2}\%p\]</span></p><p>Using this, we can compute a inverse element of <span class="math inline">\(a\)</span> by ==fast power== with modulo in <span class="math inline">\(O(\log p)\)</span></p><h3 id="way2">Way2</h3><p>Regard this congruence equation <span class="math display">\[Inv_a*a\equiv1 \pmod p\]</span> as another equation (<span class="math inline">\(x=Inv, b=p\)</span>) <span class="math display">\[a*Inv_a+p*any=1\]</span> then the only thing we need to do is that find a possible solution of the equation.</p><p>And, coincidentally, there is an algorithm <code>dedicated to</code> this kind of problem.</p><blockquote><h3 id="exgcd">Exgcd</h3><p>Quite evidently, <span class="math inline">\(a\)</span> and <span class="math inline">\(p\)</span> are coprime(according to Bézout's identity which also called Bézout's lemma),</p><p>and this algorithm is based on Euclid's algorithm. <span class="math display">\[\begin{align}Final\ state:&amp;1*1+0*0=1\ \ \ \text{i.e.}\ \ \ a=1,b=0,x=1,y=0\\Transfer:&amp;1=a*x_0+b*y_0=b*x_1+a\%b*y_1=b*x_1+(a-\lfloor\frac{a}{b}\rfloor*b)*y_1\\&amp;=a*y_1+b*(x_1-\lfloor\frac{a}{b}\rfloor*y_1)\\That\ is:&amp;x_0\gets y_1\ \text{and}\ y_0\gets x_1-\lfloor\frac{a}{b}\rfloor*y_1\end{align}\]</span> <strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;x,<span class="hljs-type">int</span>&amp;y)</span></span>&#123;b?<span class="hljs-built_in">exgcd</span>(b,a%b,y,x),y-=a/b*x:(x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>);&#125;<br>&gt;<span class="hljs-built_in">exgcd</span>(a,p,inv,x);<br>&gt;(inv+=p)%=p;<br></code></pre></td></tr></table></figure><p>Must use recursive form.</p><p>By the way, there is a small optimization of gcd here. <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&gt;<span class="hljs-keyword">while</span><span class="hljs-comment">(b^=a^=b^=a%=b)</span>;<br></code></pre></td></tr></table></figure> than, a=gcd(a,b);</p></blockquote><h3 id="way3">Way3</h3><p><span class="math display">\[\begin{align}&amp;p=\lfloor\frac{p}{a}\rfloor*a+p\%a\\\iff&amp;\lfloor\frac{p}{a}\rfloor*a\equiv-p\%a\pmod p\\\iff&amp;a^{-1}\equiv(-p\%a)^{-1}*\lfloor\frac{p}{a}\rfloor\equiv-\lfloor\frac{p}{a}\rfloor*(p\%a)^{-1}\equiv(p-\lfloor\frac{p}{a}\rfloor)*(p\%a)^{-1}\pmod p\end{align}\]</span></p><p>Since limited that <span class="math inline">\(Inv\)</span> must be positive, we must plus a <span class="math inline">\(p\)</span> before <span class="math inline">\(-\lfloor\frac{p}{a}\rfloor\)</span>.</p><p>Therefore, we can deduce <span class="math inline">\(Inv_a\)</span> from <span class="math inline">\(Inv_{p-p/a}\)</span>.</p><p>By this way, we can calculate the inverse elements from 1~n in linear time.</p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,i=<span class="hljs-number">2</span>;i&lt;p;i++)inv[i]=inv[p%i]*(p-p/i)%p;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF596E</title>
    <link href="/2022/05/30/CF596E/"/>
    <url>/2022/05/30/CF596E/</url>
    
    <content type="html"><![CDATA[<p>[[dfs]] [[trees_and_similar]] <a href="https://codeforces.com/problemset/problem/596/E">link</a></p><p>This matrix is equivalent to a forest of 基环树.</p><p>The task is to judge that there is or not a path we walk up contain the query sequence.</p><p>We don't need to care about the numbers in the cycles, since we can turn any numbers of cycles.</p><p>So, we'd better reserve the query sequence.</p><p>Then, it's a dfs problem that find a set of numbers on the nodes in a few trees.</p><h3 id="processes">Processes</h3><p>create connection</p><p>build reserve graph</p><p>find cycles</p><p>find roots below cycles</p><p>deal with queries</p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> n,m,q,r[<span class="hljs-number">202</span>][<span class="hljs-number">202</span>],nt[N],nxt[N],t,h[N],to[N],num[N],dx[<span class="hljs-number">10</span>],dy[<span class="hljs-number">10</span>];<br><span class="hljs-type">char</span> a,qu[<span class="hljs-number">1000006</span>];<br><span class="hljs-type">int</span> cy[N],cyc,c,f[N],ind[N][<span class="hljs-number">10</span>],in_cyc[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;ro[N];<br><span class="hljs-type">bool</span> fl,fla;<br><span class="hljs-type">int</span> uu,len,it;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>nxt[++t]=h[u],h[u]=t,to[t]=v;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_cycles</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cy[u])&#123;<br>fl=<span class="hljs-number">1</span>;c=cy[u];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(f[u])&#123;<br>fl=<span class="hljs-number">1</span>;c=++cyc;<br>fla=<span class="hljs-number">1</span>;uu=u;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>f[u]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">find_cycles</span>(nt[u]);<br><span class="hljs-keyword">if</span>(fl)cy[u]=c;<br><span class="hljs-keyword">if</span>(fla)&#123;<br>in_cyc[u]=ind[c][num[u]]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(u==uu)fla=<span class="hljs-number">0</span>;<br>&#125;<br>f[u]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(num[u]==qu[it]-<span class="hljs-string">&#x27;0&#x27;</span>)it++;<br><span class="hljs-keyword">if</span>(it==len)&#123;<br>fl=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[u];e;e=nxt[e])&#123;<br><span class="hljs-built_in">dfs</span>(to[e]);<br><span class="hljs-keyword">if</span>(fl==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(num[u]==qu[it]-<span class="hljs-string">&#x27;0&#x27;</span>)it--;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(num[u]==qu[it]-<span class="hljs-string">&#x27;0&#x27;</span>)it--;<br>&#125;<br><span class="hljs-type">int</span> nx,ny;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>cin&gt;&gt;a;r[i][j]=a-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)cin&gt;&gt;dx[i]&gt;&gt;dy[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//edge</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>nx=i+dx[r[i][j]];<br>ny=j+dy[r[i][j]];<br><span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">0</span>||nx&gt;=n||ny&lt;<span class="hljs-number">0</span>||ny&gt;=m)nt[m*i+j]=m*i+j;<br><span class="hljs-keyword">else</span> nt[m*i+j]=nx*m+ny;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//reverse</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br><span class="hljs-built_in">add</span>(nt[i*m+j],i*m+j);<br>num[i*m+j]=r[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br><span class="hljs-keyword">if</span>(!cy[i*m+j])fl=<span class="hljs-number">0</span>,fla=<span class="hljs-number">0</span>,<span class="hljs-built_in">find_cycles</span>(i*m+j);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[i*m+j];e;e=nxt[e])&#123;<br><span class="hljs-keyword">if</span>(in_cyc[i*m+j]&amp;&amp;<span class="hljs-comment">/*&lt;-lost*/</span>!in_cyc[to[e]])ro[cy[i*m+j]].<span class="hljs-built_in">push_back</span>(to[e]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(;q--;)&#123;<br>cin&gt;&gt;qu;len=<span class="hljs-built_in">strlen</span>(qu);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=len<span class="hljs-number">-1</span>;a&lt;b;a++,b--)qu[a]^=qu[b]^=qu[a]^=qu[b];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cyc;i++)&#123;<br><span class="hljs-keyword">for</span>(it=<span class="hljs-number">0</span>;it&lt;len&amp;&amp;ind[i][qu[it]-<span class="hljs-string">&#x27;0&#x27;</span>];it++);<br><span class="hljs-keyword">if</span>(it==len)&#123;cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-keyword">goto</span> out;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u:ro[i])&#123;<br>fl=<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(u);<br><span class="hljs-keyword">if</span>(fl==<span class="hljs-number">1</span>)&#123;cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-keyword">goto</span> out;&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>out:;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF385E</title>
    <link href="/2022/05/30/CF385E/"/>
    <url>/2022/05/30/CF385E/</url>
    
    <content type="html"><![CDATA[<p>[[math]] [[matrices]] [[fast_exponentiation]] <a href="https://codeforces.com/problemset/problem/385/E">link</a></p><p>Consider ignoring the modulo, then calculate at the same time. <span class="math display">\[\begin{aligned}dx&amp;=x+y+dx+t\\dy&amp;=x+y+dy+t\\x&amp;=dx+2x+y+t\\y&amp;=dy+x+2y+t\\t&amp;=t+1\end{aligned}\]</span> [[Pasted image 20220529224154.png]] ## Matrix fast exponentiation</p><p><span class="math display">\[\begin{aligned}dx=1*dx+0*dy+1*x+1*y+1*t+0*1\\dy=0*dx+1*dy+1*x+1*y+1*t+0*1\\x=1*dx+0*dy+2*x+1*y+1*t+0*1\\y=0*dx+1*dy+1*x+2*y+1*t+0*1\\t=0*dx+0*dy+0*x+0*y+1*t+1*1\\ 1=0*dx+0*dy+0*x+0*y+0*t+1*1\end{aligned}\]</span></p><p>We can use matrices to describe it.</p><p><span class="math display">\[\left[\begin{array}{}dx&amp;dy&amp;x&amp;y&amp;t&amp;1\end{array}\right]\left[\begin{array}{}1&amp;0&amp;1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;1&amp;0&amp;0\\1&amp;1&amp;2&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;2&amp;0&amp;0\\1&amp;1&amp;1&amp;1&amp;1&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;1\end{array}\right]=\left[\begin{array}{}x+y+dx+t\\x+y+dy+t\\dx+2x+y+t\\dy+x+2y+t\\t+1\\1\end{array}\right]\]</span> Notice the 1.</p><p>Then we can use matrix fast exponentiation.</p><p>It consists of fast exponentiation, multiplication and square.</p><p>==Multiplication== is a multiplication of matrices of (n,n) and (1,n), whose answer is a matrix of (n,1)</p><p>==Square== is a multiplication of two matrices of (n,n), whose answer is also a matrix of (n,n)</p><p>==Fast exponentiation== is the same of the fast exponentiation of numbers.</p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n,x,y,dx,dy,t,ret;<br>ll _[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>]=&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;<br>&#125;,o[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>],a[<span class="hljs-number">6</span>],b[<span class="hljs-number">6</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mult</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br><span class="hljs-keyword">for</span>(b[i]=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)(b[i]+=_[j][i]*a[j])%=n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)a[i]=b[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">square</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j,k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)<br><span class="hljs-keyword">for</span>(o[i][j]=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">6</span>;k++)<br>(o[i][j]+=_[i][k]*_[k][j])%=n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)_[i][j]=o[i][j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fpw</span><span class="hljs-params">(ll a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(;a;a&gt;&gt;=<span class="hljs-number">1</span>,<span class="hljs-built_in">square</span>())<span class="hljs-keyword">if</span>(a&amp;<span class="hljs-number">1</span>)<span class="hljs-built_in">mult</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;x,&amp;y,&amp;dx,&amp;dy,&amp;t);<br><span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>,x,y),<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>dx=(dx%n+n)%n;dy=(dy%n+n)%n;<br>a[<span class="hljs-number">0</span>]=dx,a[<span class="hljs-number">1</span>]=dy,a[<span class="hljs-number">2</span>]=x,a[<span class="hljs-number">3</span>]=y;a[<span class="hljs-number">5</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">fpw</span>(t);<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>)a[<span class="hljs-number">2</span>]=n;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>)a[<span class="hljs-number">3</span>]=n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>,a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF372D</title>
    <link href="/2022/05/30/CF372D/"/>
    <url>/2022/05/30/CF372D/</url>
    
    <content type="html"><![CDATA[<p>[[two_pointers]] [[LCA]] [[dfs_order]] [[map]] [[subtree]] <a href="https://codeforces.com/problemset/problem/1662/D">This problem</a> took me three nights.</p><p>Calculate the longest length of interval of indices of nodes in a subtree whose size is less than k.</p><h2 id="sol">Sol</h2><p>Binary search, search the answer? every check at most cost <span class="math inline">\(O(n\log n)\)</span>, and all in <span class="math inline">\(O(n\log^2n)\)</span> .</p><p>No, there is simpler solution.</p><p>Use two pointers (尺取法 in Chinese).</p><p>Then consider how to add and delete an index.</p><p>What we need to know is how to calculate the distance from a node to a subtree.(the part of function <code>Cnt</code>)</p><p>It's so hard so I thought so long, and got nothing.</p><figure><img src="C:_WD_\Tutorial\Attachment\1.jpg" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h2 id="code">Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100005</span>,M=<span class="hljs-number">200005</span>;<br><span class="hljs-type">int</span> k,n,a,b;<br><span class="hljs-type">int</span> t,h[N],nxt[M],to[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>nxt[++t]=h[u],h[u]=t,to[t]=v;<br>nxt[++t]=h[v],h[v]=t,to[t]=u;<br>&#125;<br><span class="hljs-type">int</span> cnt,dfn[N],dep[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>dfn[u]=++cnt;f[u][<span class="hljs-number">0</span>]=fa;dep[u]=dep[fa]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)f[u][i]=f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e=h[u];e;e=nxt[e])<span class="hljs-keyword">if</span>(to[e]!=fa)<span class="hljs-built_in">dfs</span>(to[e],u);<br>&#125;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;ord;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-type">int</span> sz,ans,dx,dy;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>dx=dep[x],dy=dep[y];<br><span class="hljs-keyword">if</span>(dep[x]&lt;dep[y])<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y])x=f[x][i];<br><span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> dx+dy<span class="hljs-number">-2</span>*dep[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];<br><span class="hljs-keyword">return</span> dx+dy<span class="hljs-number">-2</span>*(dep[x]<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(ord.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-built_in">dis</span>(p,ord.<span class="hljs-built_in">begin</span>()-&gt;second);<br>it=ord.<span class="hljs-built_in">upper_bound</span>(dfn[p]);<br><span class="hljs-keyword">if</span>(it==ord.<span class="hljs-built_in">end</span>()||it==ord.<span class="hljs-built_in">begin</span>())&#123;<br>x=ord.<span class="hljs-built_in">begin</span>()-&gt;second;<br>y=ord.<span class="hljs-built_in">rbegin</span>()-&gt;second;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>x=it-&gt;second;it--;<br>y=it-&gt;second;<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">dis</span>(p,x)+<span class="hljs-built_in">dis</span>(p,y)-<span class="hljs-built_in">dis</span>(x,y))/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>sz+=<span class="hljs-built_in">Cnt</span>(x);<br>ord[dfn[x]]=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>ord.<span class="hljs-built_in">erase</span>(dfn[x]);<br>sz-=<span class="hljs-built_in">Cnt</span>(x);<br>&#125;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b),<span class="hljs-built_in">add</span>(a,b);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(ord[dfn[<span class="hljs-number">1</span>]]=sz=l=ans=<span class="hljs-number">1</span>,r=<span class="hljs-number">2</span>;r&lt;=n;r++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">Add</span>(r);sz&gt;k;<span class="hljs-built_in">Del</span>(l++));<br>ans=<span class="hljs-built_in">max</span>(ans,r-l+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF367E</title>
    <link href="/2022/05/30/CF367E/"/>
    <url>/2022/05/30/CF367E/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] [[interval]] <a href="https://codeforces.com/problemset/problem/367/E">link</a></p><h2 id="pro">Pro</h2><p>Calculate the number of states(interval sequence) meet following conditions:</p><ul><li><p>Each interval does not belong to any other interval.</p></li><li><p>Exist one <span class="math inline">\(l_i=x\)</span> .</p></li></ul><p><span class="math inline">\(n, m, x (1 ≤ n·m ≤ 100000, 1 ≤ x ≤ m)\)</span> — the number of segments in the sequence, the constraints on the numbers in segments and Sereja's favourite number.</p><h2 id="sol">Sol</h2><p><span class="math inline">\(n\)</span> must &lt;= <span class="math inline">\(m\)</span>.</p><p>State as <span class="math inline">\(dp_{i,l,r}\)</span> is too big.</p><p>How can we represent the states more properly? Since the intervals don't belong to each other, the order of start and end position of intervals is fixed.</p><p>see this picture <img src="C:_WD_\Tutorial\Attachment\3.png" alt="1" /></p><p><span class="math inline">\(dp_{p,i,j}\)</span> has four transfer equations.</p><p>whether start a new interval, and whether finish the farthest interval.</p><p>After a seris of optimization, the code is following</p><blockquote><p>Reverse the traversal direction, so we can remove the p dimention.</p><p>We must open a new interval when <span class="math inline">\(p=x\)</span>, so the next states can only be added twice.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1000000007</span>,N=<span class="hljs-number">333</span>;<br><span class="hljs-type">int</span> n,m,x,o,a,f[N][N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o)</span></span>&#123;o+=a;<span class="hljs-keyword">if</span>(o&gt;=mod)o-=mod;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> p,i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x);<br><span class="hljs-keyword">if</span>(n&gt;m)<span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>),<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(p=f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;p&lt;=m;p++)&#123;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-built_in">min</span>(p,n);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">for</span>(j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(a=f[i][j])&#123;<br><span class="hljs-built_in">add</span>(f[i+<span class="hljs-number">1</span>][j]);<br><span class="hljs-built_in">add</span>(f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span>(p==x)f[i][j]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&lt;i)<span class="hljs-built_in">add</span>(f[i][j+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=f[n][n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ans=ans*i%mod;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>Complexity: <span class="math inline">\(O(m*n^2)\)</span>, at most 3e7.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF283E</title>
    <link href="/2022/05/30/CF283E/"/>
    <url>/2022/05/30/CF283E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/283/E">link</a></p><p>[[sweep_line]] [[segment_tree]] [[math]]</p><p>This will go over the basic outline for solution.</p><p>The first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow.</p><p>Call three cows "unbalanced" if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows).</p><p>Thus, <span class="math inline">\(\text{balenced}+\text{unbalanced}=C_n^3\)</span>.</p><p>So to count the number of balanced, it suffices to count the number of unbalanced.</p><p>But it is easy to show that <span class="math inline">\(\text{unbalanced}=\sum_{cows_i}C_{out_i}^2\)</span>, ([[CF1662N|a similar idea]]) so <span class="math inline">\(\text{balanced}=C_n^3-\sum_{cows_i}C_{out_i}^2\)</span>.</p><p>Now sort the skill levels of the cows (the order of the <span class="math inline">\(s_i\)</span> doesn’t actually matter). <span class="math inline">\(s_1\)</span> is lowest skill.</p><p>Now consider an <span class="math inline">\(n × n\)</span> grid where the i-th row and j-th column of the grid is a 1 if the match between cow <span class="math inline">\(i\)</span> and cow <span class="math inline">\(j\)</span> is flipped.</p><p>The grid is initially all zeros and Farmer John’s query simply flips a rectangle of the form <span class="math inline">\([a, b] × [a, b]\)</span>.</p><p>We can process these queries and compute the number of wins for each cow using a vertical sweep line on the grid and updating with a seg tree on the interval <span class="math inline">\([1,n]\)</span>. The seg tree needs to handle queries of the form</p><ul><li>Flip all numbers (0-&gt;1, 1-&gt;0) in a range <span class="math inline">\([a, b]\)</span>.</li><li>Query number of 1 in a range <span class="math inline">\([a, b]\)</span>.</li></ul><p>Note that given this seg tree we can compute the number of wins for each cow at every point in the sweep line as</p><p><span class="math display">\[\begin{aligned}&amp;\text{Number of 1 in range [ 1 , i - 1 ]} + \text{Number of 0 in range [ i + 1, n ]}\\=&amp; \text{Number of 1 in range [ 1 , i - 1 ]} +  N-i-\text{Number of 1 in range [ i + 1, n ]}\end{aligned}\]</span></p><p>There are <span class="math inline">\(m\)</span> queries so this solution takes <span class="math inline">\(O(m\log n)\)</span> time.</p><p>Note that the seg tree needed to handle this problem is the same seg tree you need for problem <a href="http://tjsct.wikidot.com/usaco-nov08-gold">lites</a> on USACO 2008 Gold</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l+r&gt;&gt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1|1)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200005</span>;<br><span class="hljs-type">int</span> n,m,s[N],a,b,t,an[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> id,x,y;<br>&#125;po[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><span class="hljs-type">int</span> su[N&lt;&lt;<span class="hljs-number">1</span>],lz[N&lt;&lt;<span class="hljs-number">1</span>],x,y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(lz[p])&#123;<br>lz[ls]^=<span class="hljs-number">1</span>;<br>lz[rs]^=<span class="hljs-number">1</span>;<br>su[ls]=mid-l+<span class="hljs-number">1</span>-su[ls];<br>su[rs]=r-mid-su[rs];<br>lz[p]^=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>su[p]=su[ls]+su[rs];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>su[p]^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;<br>lz[p]^=<span class="hljs-number">1</span>;<br>su[p]=r-l+<span class="hljs-number">1</span>-su[p];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">down</span>(l,r,p);<br><span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-built_in">update</span>(l,mid,ls);<br><span class="hljs-keyword">if</span>(y&gt;mid)<span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,rs);<br><span class="hljs-built_in">up</span>(p);<br>&#125;<br><span class="hljs-type">int</span> o;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>o+=su[p];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;<br>o+=su[p];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">down</span>(l,r,p);<br><span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-built_in">query</span>(l,mid,ls);<br><span class="hljs-keyword">if</span>(mid&lt;y)<span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,rs);<br><span class="hljs-built_in">up</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;s[i]);<br>&#125;<br><span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>a=<span class="hljs-built_in">lower_bound</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n,a)-s;<br>b=<span class="hljs-built_in">upper_bound</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n,b)-s;<br><span class="hljs-keyword">if</span>(a&gt;b<span class="hljs-number">-1</span>)<span class="hljs-keyword">continue</span>;<br>po[++t]=&#123;a,a,b<span class="hljs-number">-1</span>&#125;;<br>po[++t]=&#123;b,a,b<span class="hljs-number">-1</span>&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(po+<span class="hljs-number">1</span>,po+<span class="hljs-number">1</span>+t,[](A a,A b)&#123;<br><span class="hljs-keyword">return</span> a.id&lt;b.id;<br>&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,c=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(;po[c].id==i;c++)<br>x=po[c].x,y=po[c].y,<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<br>an[i]=n-i;<br>x=<span class="hljs-number">1</span>,y=i<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(x&lt;=y)o=<span class="hljs-number">0</span>,<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>),an[i]+=o;<br>x=i+<span class="hljs-number">1</span>,y=n;<span class="hljs-keyword">if</span>(x&lt;=y)o=<span class="hljs-number">0</span>,<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>),an[i]-=o;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)ans+=<span class="hljs-number">1ll</span>*an[i]*(an[i]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>ans=<span class="hljs-number">1ll</span>*(n<span class="hljs-number">-2</span>)*(n<span class="hljs-number">-1</span>)*n/<span class="hljs-number">6</span>-ans;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF261E</title>
    <link href="/2022/05/30/CF261E/"/>
    <url>/2022/05/30/CF261E/</url>
    
    <content type="html"><![CDATA[<p>[[DP]] [[two_pointers]] <a href="https://codeforces.com/contest/261/problem/E">link</a> A hint: There is near 3000000 numbers with maximal prime divisor &lt;=100.</p><p>According to the hint, we can list all the passible numbers. Then what we need to do is judge whether the number meets the condition or not.</p><p>We must make the cost smaller, so we can't simply mark all the prime divisors of each number.</p><p>We need to combine several divisors. And, the maximal prime divisors must be selected (a conclusion).</p><p>We can do DP, by two pointers, in the sorted list.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3000006</span>;<br><span class="hljs-type">int</span> a[N],f[N],b[N],l,r,n,m,ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;n);<br>a[m++]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>;j&lt;i;j++)<span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> E;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<span class="hljs-keyword">if</span>(<span class="hljs-number">1ll</span>*a[j]*i&lt;=r)a[m++]=a[j]*i;<br>E:;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+m);<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//DP and two_pointers </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;j&lt;m;j++)<br><span class="hljs-keyword">if</span>(a[j]%i==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(f[k]+<span class="hljs-number">1</span>&lt;f[j])&#123;<br>f[j]=f[k]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(f[j]+i&lt;=n)b[j]=<span class="hljs-number">1</span>;<br>&#125;<br>k++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-keyword">if</span>(a[i]&gt;=l&amp;&amp;b[i])ans++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF235C</title>
    <link href="/2022/05/30/CF235C/"/>
    <url>/2022/05/30/CF235C/</url>
    
    <content type="html"><![CDATA[<p>[[SAM]] &gt; So he wants to ask "how many consecutive substrings of <span class="math inline">\(s\)</span> are cyclical isomorphic to a given string <span class="math inline">\(x\)</span>". You are given string <span class="math inline">\(s\)</span> and <span class="math inline">\(n\)</span> strings <span class="math inline">\(x_i\)</span>, for each string <span class="math inline">\(x_i\)</span> find, how many consecutive substrings of <span class="math inline">\(s\)</span> are cyclical isomorphic to <span class="math inline">\(x_i\)</span>.</p><p>Because I've learned suffix automaton, when I saw <a href="https://codeforces.com/contest/235/problem/C">this problem</a>, I knew I should use <a href="SAM.md">SAM</a>.</p><h2 id="sol">Sol</h2><p>First, consider an easier problem.</p><blockquote><p>How many times does a string <span class="math inline">\(x\)</span> occur in a string <span class="math inline">\(s\)</span> ?</p></blockquote><p>It's a typical application of SAM.</p><p>What we need to do is just build a SAM on string <span class="math inline">\(s\)</span>, then update the times every state occurs (by topo or dfs). Then, we can read the query string <span class="math inline">\(x\)</span>. Walk in the automaton by <code>ch</code> while iterating <span class="math inline">\(x\)</span>. Find the latest state included <span class="math inline">\(x\)</span>. Finally, print the times of this state.</p><blockquote><p>How many consecutive substrings of <span class="math inline">\(s\)</span> are cyclical isomorphic to a given string <span class="math inline">\(x\)</span> ?</p></blockquote><p>Obviously, the complexity is the same. We should do operations in linear time.</p><p><strong>ADD to the rightmost and DELETE the leftmost.</strong></p><p>We can walk forwards by <code>ch</code> and walk backwards by <code>fa</code>.</p><p>If we have no way forwards, we turn back to find ways. If we do that, the leftmost characters will be deleted.</p><p>If the length of current state reaches <span class="math inline">\(|x|\)</span>, we must delete the leftmost character(this operation might make you walk back).</p><p>In addition, the times of every passible kinds of <span class="math inline">\(x\)</span> can only be added once.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> l(x) _[x].len</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chp _[p].ch[c]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fa(x) _[x].fa</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2000006</span>;<br><span class="hljs-type">int</span> t,n,p,np,la=<span class="hljs-number">1</span>,q,nq,T=<span class="hljs-number">1</span>,sz[N],l,ans,vis[N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<span class="hljs-type">int</span> fa,ch[<span class="hljs-number">26</span>],len;&#125;_[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>&#123;<br><span class="hljs-keyword">for</span>(p=la,la=np=++T,sz[np]=<span class="hljs-number">1</span>,<span class="hljs-built_in">l</span>(np)=<span class="hljs-built_in">l</span>(p)+<span class="hljs-number">1</span>;p&amp;&amp;!chp;p=<span class="hljs-built_in">fa</span>(p))chp=np;<br><span class="hljs-keyword">if</span>(!p)&#123;<span class="hljs-built_in">fa</span>(np)=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">l</span>(q=chp)==<span class="hljs-built_in">l</span>(p)+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">fa</span>(np)=q;<span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">for</span>(nq=++T,_[nq]=_[q],<span class="hljs-built_in">l</span>(nq)=<span class="hljs-built_in">l</span>(p)+<span class="hljs-number">1</span>,<span class="hljs-built_in">fa</span>(np)=<span class="hljs-built_in">fa</span>(q)=nq;p&amp;&amp;chp==q;p=<span class="hljs-built_in">fa</span>(p))chp=nq;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:e[u])<span class="hljs-built_in">dfs</span>(x),sz[u]+=sz[x];&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,cin&gt;&gt;s;s[i];i++)<span class="hljs-built_in">add</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=T;i++)e[<span class="hljs-built_in">fa</span>(i)].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(cin&gt;&gt;t,t++;--t;)&#123;<br>cin&gt;&gt;s;n=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-built_in">strcpy</span>(s+n,s);<br><span class="hljs-keyword">for</span>(ans=l=i=<span class="hljs-number">0</span>,p=<span class="hljs-number">1</span>;s[i];i++)&#123;<br><span class="hljs-keyword">for</span>(;p&amp;&amp;!_[p].ch[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];)l=<span class="hljs-built_in">l</span>(p=<span class="hljs-built_in">fa</span>(p));<br><span class="hljs-keyword">if</span>(!p)&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">goto</span> E;&#125;<br>l++,p=_[p].ch[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>l==n&amp;&amp;(vis[p]!=t&amp;&amp;(vis[p]=t,ans+=sz[p]),--l==<span class="hljs-built_in">l</span>(<span class="hljs-built_in">fa</span>(p))&amp;&amp;(p=<span class="hljs-built_in">fa</span>(p)));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);E:;<br>&#125;<br>&#125;<br><span class="hljs-comment">/*use topo</span><br><span class="hljs-comment">int deg[N],r,que[N],o;</span><br><span class="hljs-comment">void get_size()&#123;</span><br><span class="hljs-comment">for(int i=1;i&lt;=tot;i++)deg[fa(i)]++;</span><br><span class="hljs-comment">for(int i=1;i&lt;=tot;i++)if(!deg[i])que[r++]=i;</span><br><span class="hljs-comment">for(;l&lt;=r;l++)&#123;</span><br><span class="hljs-comment">o=que[l];</span><br><span class="hljs-comment">sz[fa(o)]+=sz[o];</span><br><span class="hljs-comment">if(!--deg[fa(o)])que[r++]=fa(o);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure><p>This is the shortest solution code in CF.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CF232D</title>
    <link href="/2022/05/30/CF232D/"/>
    <url>/2022/05/30/CF232D/</url>
    
    <content type="html"><![CDATA[<p>[[discretization]] [[SA]] (suffix array) [[binary_search]] [[sweep_line]] [[BIT]] (Binary Indexed Tree)</p><p><a href="https://codeforces.com/contest/232/problem/D">link</a></p><p>OHHHHH OHHHH OHHHHHHHHH I made it!!!!</p><h2 id="process">Process</h2><p>Change the original sequence to a difference array(差分数组).</p><p>And the interval which is able to be matched is the same as the reversed(negative) inquiring interval in difference array.</p><p>We should find out all the interval able to be matched, so we can use suffix array.</p><p>To get the start positions of the inquiring interval, we can put the reversed sequence to the back of positive-going sequence, separated by inf.</p><p>Now, I can get all the intervals which meet the second and third conditions via binary search(once left, once right).</p><p>But, we don't completely that (see the range of data).</p><p>How to deal with the intersect condition? <strong>offline</strong></p><p>We can make operations in <span class="math inline">\(O(\log n)\)</span> time.</p><p>Considering sweep line.</p><p>For each difference between two fences, only allowed to be calculated once.</p><p>We could solve it using BIT or segment tree or other structure that support queries of sum on an interval and increment(单点修改) of an element.</p><p>Cause this became a counting-nodes problem.</p><p>Pay attention to the gap near end pos, start pos, the add item and the subtract item.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">400005</span>;<br><span class="hljs-type">int</span> t,tot,n,nn,Q,m,r[N],d[N];<br><span class="hljs-type">int</span> t1[N],t2[N],sa[N],w[N],h[N],rk[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SA</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> *as=t1,*psa=t2,p,i,j,k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=m;i++)w[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)w[r[i]]++;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)w[i]+=w[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(i=n;i;i--)sa[w[as[i]=r[i]]--]=i;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;;j&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(p=<span class="hljs-number">0</span>,i=n+<span class="hljs-number">1</span>-j;i&lt;=n;i++)psa[++p]=i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(sa[i]&gt;j)psa[++p]=sa[i]-j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=m;i++)w[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)w[as[psa[i]]]++;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)w[i]+=w[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(i=n;i;i--)sa[w[as[psa[i]]]--]=psa[i];<br><span class="hljs-keyword">for</span>(m=psa[sa[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>,i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>psa[sa[i]]=(as[sa[i]]==as[sa[i<span class="hljs-number">-1</span>]]&amp;&amp;as[sa[i]+j]==as[sa[i<span class="hljs-number">-1</span>]+j]?m:++m);<br><span class="hljs-keyword">if</span>(m==n)<span class="hljs-keyword">break</span>;<span class="hljs-built_in">swap</span>(as,psa);<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)rk[i]=psa[i];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>j=sa[rk[i]<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">while</span>(r[i+k]==r[j+k])k++;<br>h[rk[i]]=k;<span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)k--;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> f[N&lt;&lt;<span class="hljs-number">1</span>][<span class="hljs-number">25</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RMQ</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)f[i][<span class="hljs-number">0</span>]=h[i];<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">21</span>;j++)<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)<br>f[i][j]=<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;j<span class="hljs-number">-1</span>)][j<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">int</span> len,x,y,_;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check1</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>ret=<span class="hljs-number">1000006</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">21</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(p+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=_)&#123;<br>ret=<span class="hljs-built_in">min</span>(f[p][j],ret);<br>p+=<span class="hljs-number">1</span>&lt;&lt;j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ret&lt;len)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check2</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>ret=<span class="hljs-number">1000006</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">21</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(p-(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-number">1</span>&gt;_)&#123;<br>ret=<span class="hljs-built_in">min</span>(f[p-(<span class="hljs-number">1</span>&lt;&lt;j)+<span class="hljs-number">1</span>][j],ret);<br>p-=<span class="hljs-number">1</span>&lt;&lt;j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ret&lt;len)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NODE</span>&#123;<br><span class="hljs-type">int</span> id,x,y,p,o;<br>&#125;q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erf</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-number">2</span>,r=_,mid;<span class="hljs-comment">//&lt;---2</span><br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check1</span>(mid))r=mid<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br>q[tot].o=<span class="hljs-number">-1</span>;<br>q[tot].p=r<span class="hljs-number">-1</span>;<br>l=_+<span class="hljs-number">1</span>,r=n;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check2</span>(mid))r=mid<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br>q[tot+<span class="hljs-number">1</span>].o=<span class="hljs-number">1</span>;<br>q[tot+<span class="hljs-number">1</span>].p=r;<br>&#125;<br><span class="hljs-type">int</span> bi[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">for</span>(;p&lt;=nn;p+=p&amp;-p)bi[p]++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">for</span>(ret=<span class="hljs-number">0</span>;p;p-=p&amp;-p)ret+=bi[p];<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-type">int</span> ans[N],cnt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;r[i]);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>d[i]=r[i+<span class="hljs-number">1</span>]-r[i],<br>d[i+n]=-d[i];<br>&#125;d[n]=<span class="hljs-number">1e9</span>;<br>nn=n;n=n*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)r[i]=d[i];<br><span class="hljs-built_in">sort</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>+n);<br>m=<span class="hljs-built_in">unique</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>+n)-d;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)r[i]=<span class="hljs-built_in">lower_bound</span>(d+<span class="hljs-number">1</span>,d+m,r[i])-d;m=n;<br><span class="hljs-built_in">SA</span>();<span class="hljs-built_in">RMQ</span>();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Q);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=Q;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br><span class="hljs-keyword">if</span>(x==y)&#123;<br>ans[i]=nn<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>len=y-x;_=rk[x+nn];<span class="hljs-built_in">erf</span>();<br>q[tot].x=q[tot+<span class="hljs-number">1</span>].x=<span class="hljs-built_in">max</span>(x<span class="hljs-number">-1</span>-len,<span class="hljs-number">0</span>);<br>q[tot].y=q[tot+<span class="hljs-number">1</span>].y=y;<br>q[tot].id=q[tot+<span class="hljs-number">1</span>].id=i;<br>tot+=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">sort</span>(q,q+tot,[](NODE a,NODE b)&#123;<br><span class="hljs-keyword">return</span> a.p&lt;b.p;<br>&#125;);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//&lt;---0</span><br><span class="hljs-keyword">if</span>(sa[i]&lt;=nn&amp;&amp;sa[i]&gt;=<span class="hljs-number">1</span>)<span class="hljs-built_in">up</span>(sa[i]),cnt++;<br><span class="hljs-keyword">for</span>(;q[t].p==i&amp;&amp;t&lt;tot;t++)<br>ans[q[t].id]+=q[t].o*(cnt-<span class="hljs-built_in">down</span>(q[t].y)+<span class="hljs-built_in">down</span>(q[t].x));<br><span class="hljs-keyword">if</span>(t&gt;=tot)<span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=Q;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>There is another way to implement the function <code>LCP</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCP</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//the LCP between two suffixes, ranked x and y in the suffix array.</span><br><span class="hljs-keyword">if</span>(x&gt;y)<span class="hljs-built_in">swap</span>(x,y);x++;<br><span class="hljs-type">int</span> k=LG[y-x+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(st[x][k],st[y-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/29/hello-world/"/>
    <url>/2022/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
